Module sext
===========


<h1>Module sext</h1>

* [Description](#description)
* [Function Index](#index)
* [Function Details](#functions)


Sortable serialization library.



__Authors:__ Ulf Wiger ([`ulf.wiger@erlang-consulting.com`](mailto:ulf.wiger@erlang-consulting.com)).

<h2><a name="index">Function Index</a></h2>



<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decodes a binary generated using the function <a href="sext.md#encode-1"><code>sext:encode/1</code></a>.</td></tr><tr><td valign="top"><a href="#decode_sb32-1">decode_sb32/1</a></td><td>Decodes a binary generated using the function <a href="#encode_sb32-1"><code>encode_sb32/1</code></a>.</td></tr><tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Encodes any Erlang term into a binary.</td></tr><tr><td valign="top"><a href="#encode_sb32-1">encode_sb32/1</a></td><td>Encodes any Erlang term into a binary.</td></tr><tr><td valign="top"><a href="#prefix-1">prefix/1</a></td><td>Encodes a binary for prefix matching of similar encoded terms.</td></tr></table>


<a name="functions"></a>


<h2>Function Details</h2>


<a name="decode-1"></a>


<h3>decode/1</h3>





<tt>decode(B::binary()) -> term()</tt>



Decodes a binary generated using the function [`sext:encode/1`](sext.md#encode-1).
<a name="decode_sb32-1"></a>


<h3>decode_sb32/1</h3>





`decode_sb32(Data) -> any()`



Decodes a binary generated using the function [`encode_sb32/1`](#encode_sb32-1).
<a name="encode-1"></a>


<h3>encode/1</h3>





<tt>encode(T::term()) -> binary()</tt>



Encodes any Erlang term into a binary.
The lexical sorting properties of the encoded binary match those of the
original Erlang term. That is, encoded terms sort the same way as the
original terms would.
<a name="encode_sb32-1"></a>


<h3>encode_sb32/1</h3>





<tt>encode_sb32(Term::any()) -> binary()</tt>





Encodes any Erlang term into a binary.
This is similar to [`encode/1`](#encode-1), but produces an octet string that  
can be used without escaping in file names (containing only the characters  
0..9, A..V and '-'). The sorting properties are preserved.

Note: The encoding used is inspired by the base32 encoding described in
RFC3548, but uses a different alphabet in order to preserve the sort order.
<a name="prefix-1"></a>


<h3>prefix/1</h3>





<tt>prefix(X::term()) -> binary()</tt>



Encodes a binary for prefix matching of similar encoded terms.
Lists and tuples can be prefixed by using the '_' marker, similarly
to Erlang match specifications. For example:

* `prefix({1,2,`_','_'})' will result in a binary that is the same as
the first part of any encoded 4-tuple with the first two elements being
1 and 2. The prefix algorithm will search for the first '_', and treat
all following elements as if they were '_'.

* `prefix([1,2|`_'])' will result in a binary that is the same as the
first part of any encoded list where the first two elements are 1 and 2.
`prefix([1,2,`_'])' will give the same result, as the prefix pattern
is the same for all lists starting with [1,2|...].

* `prefix(Binary)` will result in a binary that is the same as the encoded
version of Binary, except that, instead of padding and terminating, the
encoded binary is truncated to the longest byte-aligned binary. The same
is done for bitstrings.

* `prefix({1,[1,2|`_'],'_'})' will prefix-encode the second element, and
let it end the resulting binary. This prefix will match any 3-tuple where
the first element is 1 and the second element is a list where the first
two elements are 1 and 2.

* `prefix([1,[1|`_']|'_'])' will result in a prefix that matches all lists
where the first element is 1 and the second element is a list where the
first element is 1.

* For all other data types, the prefix is the same as the encoded term.




_Generated by EDoc, Feb 21 2011, 19:06:30._